% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_cox_mats_functions.R
\name{get_cov_mat_ns_R}
\alias{get_cov_mat_ns_R}
\title{Create a covariance matrix.}
\usage{
get_cov_mat_ns_R(V, R, sigma2eps)
}
\arguments{
\item{V}{A positive vector of length \code{n}.}

\item{R}{An \code{n x n} correlation matrix.}

\item{sigma2eps}{A positive scalar representing the variance of the noise
(or nugget).}
}
\value{
An \code{n x n} covariance matrix
}
\description{
\code{get_cov_mat_ns_R} returns a non-stationary covariance matrix (with
nugget).
}
\details{
This creates a covariance matrix, \code{C}, where
\deqn{C =  V^{0.5}RV^{0.5} + \sigma^2_\epsilon I} where V is a matrix with
process variances (from vector V above) on the diagonal,
\code{R} is a correlation matrix, and \eqn{\sigma^2_\epsilon} is the variance
 of the noise (or nugget).
}
\section{Note}{

Surprisingly, this method is substantially faster, even for relatively large
matrices (tested up to \code{5000 x 5000}), than doing sparse matrix
multiplication in the Matrix package. Sparse matrix multiplication was orders
of magnitude slower for small matrices than the method implemented above or
for \code{diag(V)^0.5 \%*\% R \%*\% diag(V)^0.5}, which was roughly the same
speed as above for small matrices, but much slower for large matrices.
}

\examples{
n <- 10
d <- 2
x <- matrix(runif(n * d), nrow = n, ncol = d)
rho <- runif(d, 0, 1)
R <- get_cor_mat_R(x, rho)
sigma2eps <- 0.01
V <- rlnorm(n, -0.1, 0.1)
get_cov_mat_ns_R(V, R, sigma2eps)
}
\seealso{
Other correlation and covariance functions: 
\code{\link{combine_cor_mats_R}()},
\code{\link{get_cor_mat_R}()},
\code{\link{get_cov_mat_s_R}()}
}
\concept{correlation and covariance functions}
